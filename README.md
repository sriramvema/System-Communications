[![Review Assignment Due Date](https://classroom.github.com/assets/deadline-readme-button-24ddc0f5d75046c5622901739e7c5dd533143b0c8e959d652212380cedb1ea36.svg)](https://classroom.github.com/a/_fBs5sT8)

I've included a makefile, so running the make command should compile everything in the folder. After everything is compiled, I run ./PrimaryLikesServer and ./parentProcess in separate terminals. The PrimaryLikesServer application has to be run first. If the parent process is run first, it will immedietly terminate because the server socket is unavailable. After the PrimaryLikesServer starts, it will wait for the parent process to begin running and it will connect to all 10 children. The parent process will terminate after five minutes, but the PrimaryLikesServer will continue running because it is in an infinite loop.

Please grade the version of my project from 11/10/2023

I began my parent process application by first creating all of the log files I needed. I had a parent process log and a log for each of the ten likes servers. The logs for the likes servers were added to an array of 10 files, the index of the logs corresponding to which likes server it was (0, 1, 2, ... , 9). Then I created an array of 10 pid_t called LikesServer[]. Each index in this array would hold one child, so LikesServer[0] would be LikesServer0 and so on. I then started a for loop to create the children. Inside the for loop was another nested for loop that I used to make sure I was in the parent application. After I have confirmed that I was in the parent, I forked the application and recorded the time that it was forked in another array called times[]. I created a function called writeTime() that was able to find the current time, convert it to local time, and format it and return a string value. I used this to record the start times in each index of times[]. Throughout this whole program, I use multiple arrays. I make sure all of the data I have corresponds to the same index as the likes server. So anything I want to record in whatever array for LikesServer0 will always be in index 0. This made it much easier to keep track of my data. After each child is forked, I run a new for loop that checks to see which child is currently being run. After I determine which child I am in, I record the start time in the parent log and run the Likes Server function, which will be explained in the next paragraph. After the LikesServer function finishes running, I have an exit(0) command for the child process. Next, I create a new array of 10 integers and name it serv[]. I run another for loop that goes through each child in the LikesServer[] array and run the waitpid command. The exit status for each child is recorded in the serv[] array. Using these exit statuses that I have recorded, I log if the server terminated successfully or due to a failure, along with the current time in the parent log. Then I close all of the files and free any memory that I have allocated. 

The LikesServer function takes in two parameters, int num and FILE* file. This way the function knows which child is running it and which file to write the log. The first thing I do inside the LikesServer function is create a client socket. This way, each child has its own connection to the server. I had previously had one socket that I created in the parent process, but this caused a lot of congestion with the servers sending messages all at once. This new method had no congestion. After the socket is created, I use time functions to create a limit of 300 seconds (or five minutes). I use this to format the while loop so that is runs for five minutes and ends. Before I enter the while loop, I use strcat and strcpy to format a string. This string will simply be LikesServer<number> and I will use this to format the messages inside the while loop that are to be sent to the primary server and also what to record in the child log. The first thing I do in the while loop is check if a signal was received from the primary server in the previous iteration. If a signal was received, it will reset the likes count to zero. Otherwise, the count will remain the same and the new count will be added to it. Then I start the message with the string I formatted before the while loop. After that, I randomly pick an integer between 0 and 42 and add it to the message. I record that message in the log, then I once again randomly pick an integer between 1 and 5. I make the child sleep for that many seconds before it sends the message to the primary server. After it receives a message back from the server, it logs a confirmation that a signal was received. Then I calculate the time that has passed to ensure that the function hasnt been running past five minutes.

I begin the primary server application by creating the server socket. I also create an array called likessockets[10]. This array will hold each socket that has been accepted from each of the child. After all of the children are created, the primary socket will have 10 connections. Then I create the primary log and write the starting total to be 0 likes. I start an infinite loop in which I first check if all of the client connections are closed. If they are all closed, I close the primary log so that data that has been written during the process can be saved. Then, I creat an fdset readfds. This will have each of the accepted connections and transfer them into the likes_socket array. After the connection is accepted, I run a for loop that runs through each index of the likes_socket array to see if any messages have been sent by the clients. If the size of the recieved message is 0, that means the client has closed and I will increase the int closed variable. Once that variable reaches 10, that means all of the sockets have been closed and the log file will be closed. If the size is not 0, it will parse the message using strtok(). It will take the number at the end of the message (which will be the number of likes from the server) and add it to the total number of likes in the primary server. I use atoi() to convert the message to an integer. Then I write the received message into the log along with the new total number of likes. After this information has been recorded, the primary server sends a signal back to the server that sent the message to confirm that it received the message. 

I'll also add print statements throughout each application so that it is easier to see what is happening.
